pub mod dkg_meta;

use crate::{BlsPrivateKey, BlsPublicKey};
use blsttc::group::ff::Field;
use blsttc::Fr;
pub use crypto::dealing::{CGCombinedDealing, CGIndividualDealing, EncryptedDealingWithProof};
pub use crypto::public_key::CGPublicKey;
pub use crypto::secret_key::CGSecretKey;
use std::collections::{BTreeMap, HashMap, HashSet};
use std::fmt::{Display, Formatter};
use bicycl::{CiphertextBox, PublicKeyBox};
use socrypto_core::api::instances::ecdsa_sig_ed25519::{SignatureEd25519Sig, SigningKeyEd25519Sig, VerificationKeyEd25519Sig};
use crypto::dealing::{DkgConfig, ShareCommitment, DealerSecret, DealingCommitmentwithCiphers, DealingMeta, AggregatedDealingCommitmentwithCiphers};
pub use crypto::dealing_signature::DealingSignature;
use crypto::errors::DkgError;
use socrypto_core::types::Hash;
use crate::utils::{compute_accumulation_value, try_create_bls_aggregate_signature};
use blst::min_pk::{Signature as SignatureBLS, PublicKey as PublicKeyBlst, AggregateSignature as AggregateSignatureBLS, AggregatePublicKey as AggregatePublicKeyBLS};
use crypto::public_key::verify_signature;
use crate::cgdkg::dkg_meta::{AggregateCommitment, AggregateEncryptedShare, DKGMeta, DKGMetaCompressed, DKGMetaWithAggregateSignature, DKGMetaWithSignature, DKGMetaZis, DealingMetaWithSignature};

pub type SecretKey = SigningKeyEd25519Sig;
pub type PublicKey = VerificationKeyEd25519Sig;
pub type Signature = SignatureEd25519Sig;

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum NodeType{
    DealerClanNode,
    FamilyNode,
    NormalTribeNode,
}

impl Display for NodeType {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            NodeType::DealerClanNode => write!(f, "ClanNode"),
            NodeType::FamilyNode => write!(f, "FamilyNode"),
            NodeType::NormalTribeNode => write!(f, "NormalTribeNode"),
        }
    }
}

/// State of the participant of Distributed Key Generation based on ClassGroup cryptography
pub struct CGDkg {
    /// Number of participants in threshold distributed key generation
    pub num_of_nodes: u32,
    /// Number of participants in threshold distributed key generation
    pub num_of_dealer_clan_nodes: u32,
    /// Threshold value of the distributed key
    /// Normally this is 2f+1 where |tribe| = 3f+1
    /// But if the dkg is for a clan, it will be same as threshold_clan i.e. f+1
    pub threshold: u32,
    /// Threshold for the dealer clan = f+1 where |clan| = 2f+1
    pub threshold_clan: u32,
    // the dealer, after sending their dealings, would wait for this time duration to collect >= threshold
    // signatures on their dealing. Once collected sigs >= threshold and timer has expired, the dealer proceeds to
    // next step
    pub dealing_sig_collection_timeout_ms: u64,
    /// Secret identity of the current participant in the key generator committee
    cg_private_key: CGSecretKey,
    /// Index of the current participant in the key generator committee
    index: u32,
    /// Whether the node is part of the DKG dealer clan or is a Family node
    node_type: NodeType,
    /// Flag indicating that collected dealings has been aggregated
    aggregated: bool,
    /// List of collected individual dealings from other dealers in the committee.
    /// Key is the dealer index in the committee,
    /// Value is the dealing assigned to current node by the dealer
    individual_dealing: BTreeMap<u32, CGIndividualDealing>,
    /// List of collected encrypted dealings from other dealers in the committee.
    /// Key is the accumulation value,
    /// Value is the encrypted ciphertext and commitment of the dealing
    pub encrypted_dealing: BTreeMap<Hash, DealingCommitmentwithCiphers>,
    ///flag to show that node has generated self encrypted dealing
    self_encrypted_dealing_generated: bool,
    /// Combined dealings generated by current instance as a dealer
    generated_dealing: Option<CGCombinedDealing>,
    /// Only clan nodes store dealing_votes/signatures for their dealings
    /// Map of voters coupled with the votes on the dealing generated by current node
    /// Key is the participant position in key generator committee
    /// Value is the signature on the dealing-hash
    dealing_votes: Option<Vec<Option<DealingSignature>>>,
    /// Only family nodes store dealing_meta_votes
    /// Clan nodes after verifying encrypted dealings send their votes to the family nodes
    /// who verify and store these votes in dealing_meta_votes and later create MetaDkg
    /// Using these votes
    dealing_meta_votes: Option<HashMap<DealingMeta, HashMap<u32, (SignatureBLS, CGPublicKey)>>>,
    /// Only clan nodes store this map
    /// voted_dkg_metas contains all dkg_metas for which the clan node has voted for and sent the vote to
    /// the family node
    pub voted_dkg_metas: Option<HashMap<Hash, DKGMetaZis>>,
    /// Only family nodes store dealing_meta_qcs
    /// Once a dealing meta has received threshold_clan votes, QC can be formed and this dealing meta is
    /// added to dealing_meta_qcs
    dealing_meta_qcs: Option<HashMap<DealingMeta, (Vec<u32>,AggregateSignatureBLS)>>,
    /// Only family nodes store DKGMeta
    /// The DKGMeta is formed when the node has collected threshold dealing_meta_qcs
    /// This DKGMeta is later posted on SMR after forming a QC
    dkg_meta: Option<DKGMetaCompressed>,
    /// Only family nodes store DKGMeta votes
    /// The clan nodes send their votes on the proposed DKGMeta by the family node
    /// These votes can later be combined to form a QC and posted on SMR
    dkg_meta_votes: Option<HashMap<u32,SignatureBLS>>,
    /// First dkg_meta QC output by the SMR
    dkg_meta_qc: Option<DKGMetaWithAggregateSignature>,
    /// Only clan nodes store dkg_meta_zis
    /// dkg_meta_zis contains list of all zi_s/accumulation values for all zi's in Meta_DKG received as a result of Deliver Protocol
    dkg_meta_zis: Option<DKGMetaZis>,
    /// Only clan nodes store dkg_meta_commitment_with_ciphers
    /// dkg_meta_commitment_with_ciphers contains all ciphers alongwith the commitments for the dealings in Meta DKG
    /// indexed by their accumulation value
    /// The clan nodes receive these by running the Deliver Protocol
    dkg_meta_commitment_with_ciphers: Option<BTreeMap<Hash, DealingCommitmentwithCiphers>>,
    /// All tribe nodes except clan nodes store this
    /// The clan nodes send the aggregate encrypted shares of tribe nodes
    /// The receiver node can decrypt after receiving threshold_clan same shares from clan nodes
    aggregate_encrypted_shares: Option<HashMap<AggregateEncryptedShare, Vec<u32>>>,
    finalized_aggregate_commitments: Option<AggregateCommitment>,
    partial_decrypted_share: Option<Fr>,
}

impl CGDkg {
    pub fn new(num_of_nodes: u32,
               num_of_dealer_clan_nodes: u32,
               threshold: u32,
               threshold_clan: u32,
               dealing_sig_collection_timeout_ms: u64,
               cg_private_key: CGSecretKey,
               index: u32,
               node_type: NodeType) -> Self {

        let mut dealing_votes = None;
        let mut dealing_meta_qcs = None;
        let mut dkg_meta_votes = None;
        let mut dkg_meta_commitment_with_ciphers = None;
        let mut voted_dkg_metas = None;
        let mut dealing_meta_votes = None;

        if node_type == NodeType::FamilyNode {
            dealing_meta_qcs = Some(HashMap::new());
            dkg_meta_votes = Some(HashMap::new());
            dealing_meta_votes = Some(HashMap::new());
        }

        // only dealer clan nodes need to store the valid_dealings and dealing_votes on their dealings
        if node_type == NodeType::DealerClanNode{
            dealing_votes = Some(vec![None; num_of_nodes as usize]);
            dkg_meta_commitment_with_ciphers = Some(BTreeMap::new());
            voted_dkg_metas = Some(HashMap::new());
        }

        CGDkg {
            num_of_nodes,
            num_of_dealer_clan_nodes,
            threshold,
            threshold_clan,
            dealing_sig_collection_timeout_ms,
            cg_private_key,
            index,
            node_type,
            aggregated: false,
            individual_dealing: BTreeMap::new(),
            encrypted_dealing: BTreeMap::new(),
            self_encrypted_dealing_generated: false,
            generated_dealing: None,
            dealing_votes,
            dealing_meta_votes,
            voted_dkg_metas,
            dealing_meta_qcs,
            dkg_meta: None,
            dkg_meta_votes,
            dkg_meta_qc: None,
            dkg_meta_zis: None,
            dkg_meta_commitment_with_ciphers,
            aggregate_encrypted_shares: None,
            finalized_aggregate_commitments: None,
            partial_decrypted_share: None,
        }
    }

    pub fn get_cg_public_key(&self) -> CGPublicKey {
        CGPublicKey::try_from(&self.cg_private_key).unwrap()
    }

    pub fn get_cg_private_key(&self) -> CGSecretKey {
        self.cg_private_key.clone()
    }

    pub fn generate_individual_dealing(&mut self, epoch: u64) -> Result<Vec<CGIndividualDealing>, DkgError> {
        if self.node_type != NodeType::DealerClanNode{
            return Err(DkgError::GeneralError(
                "Invalid Node Type".to_string(),
            ));
        }
        let config = DkgConfig{
            n: self.num_of_nodes,
            t: self.threshold,
        };
        let dealer_secret = DealerSecret::new(&config);
        let combined_dealing = dealer_secret.into_combined_dealing(&config, self.index, epoch as u32);
        let individual_dealing = combined_dealing.get_individual_dealings_without_commitment();
        self.generated_dealing = Some(combined_dealing);
        Ok(individual_dealing)
    }

    // EncryptedDealingWithProof is generated which includes a signatures for nodes that have previously signed
    // the node's dealing, It also includes ciphers for the remaining nodes and a proof of correct sharing
    pub fn generate_encrypted_dealings_with_proof(&self,
                                                  committee_nodes_encryption_keys: &BTreeMap<u32, PublicKeyBox>)
    -> Result<EncryptedDealingWithProof, DkgError>{

        if let Some(dealing_votes) = self.dealing_votes.as_ref() {
            let mut signatures = BTreeMap::new();

            for i in 0..dealing_votes.len(){
                if let Some(dealing_vote) = &dealing_votes[i]{
                    signatures.insert(i as u32, dealing_vote.signature.clone());
                }
            }

            if signatures.len() < self.threshold as usize{
                return Err(DkgError::GeneralError(format!("Expected threshold: {} dealing_votes, found: {}", self.threshold, signatures.len())));
            }

            let dealing = self.generated_dealing.as_ref().unwrap();
            EncryptedDealingWithProof::new(dealing, &signatures, committee_nodes_encryption_keys, self.threshold)
        }
        else{
            Err(DkgError::GeneralError("Invalid Node Type".to_string()))
        }
    }

    pub fn sign_and_store_dealing(
        &mut self,
        dealing: CGIndividualDealing,
        index: u32,
        epoch: u64,
    ) -> Result<DealingSignature, DkgError> {

        // basic validation
        if dealing.dealer_id != index ||
            dealing.instance_id != epoch as u32{
            return Err(DkgError::DealingVerificationError("Dealing with invalid dealer_id or instance_id".to_string()));
        }

        // the receiver does not need to validate the dealing as that is done later by the clan and family nodes
        // the receiver just need to sign his public share and store the dealing
        let sig = self.cg_private_key.sign_commitment(&dealing);
        self.individual_dealing.insert(index, dealing);
        Ok(sig)
    }

    // If a node is a clan node, they will validate and store the dealing and send a signature on the dealing
    // to family nodes
    pub fn validate_and_sign_encrypted_dealing(
        &mut self,
        dealing: EncryptedDealingWithProof,
        index: u32,
        epoch: u64,
        committee_nodes_pks: &BTreeMap<u32, CGPublicKey>,
    ) -> Result<DealingMetaWithSignature, DkgError> {

        // only need to verify the dealing if self is a dealer clan
        if self.node_type.clone() != NodeType::DealerClanNode{
            return Err(DkgError::GeneralError("Invalid Node Type".to_string()));
        }

        // basic validation
        if dealing.dealing_commitment.dealer_id != index ||
            dealing.dealing_commitment.instance_id != epoch as u32{
            return Err(DkgError::EncryptedDealingVerificationError("Dealing with invalid dealer_id or instance_id".to_string()));
        }

        if !dealing.verify(committee_nodes_pks, self.threshold.clone()){
            return Err(DkgError::EncryptedDealingVerificationError(
                "Encrypted Dealing verification failed".to_string(),
            ));
        }

        let (accumulation_value, dealing_commitment_with_ciphers) = self.compute_accumulation_value_encrypted_dealing(&dealing)?;
        self.encrypted_dealing.insert(accumulation_value, dealing_commitment_with_ciphers);

        let commitment_key_12381 = dealing.dealing_commitment.bls12381_commitment.evals[0].clone();

        let dealing_meta = DealingMeta{
            dealer_id: dealing.dealing_commitment.dealer_id,
            instance_id: dealing.dealing_commitment.instance_id,
            accumulation_value: accumulation_value.0,
            commitment_sk_12381: commitment_key_12381,
        };
        let signature = self.cg_private_key.sign_bls(&dealing_meta.to_vec());

        Ok(
            DealingMetaWithSignature{
                dealing_meta,
                signature
            }
        )
    }

    fn compute_accumulation_value_encrypted_dealing(&self, dealing: &EncryptedDealingWithProof)-> Result<(Hash, DealingCommitmentwithCiphers), DkgError>{

        let dealing_commitment = dealing.dealing_commitment.clone();

        let mut ciphers_with_proof_map = BTreeMap::new();
        if let Some(ciphers_with_sharing_proof) = dealing.ciphers_with_sharing_proof.as_ref(){
            let ciphers_with_proof = ciphers_with_sharing_proof.ciphers_with_sharing_proof_12381.ciphers.clone();

            let signer_indices = dealing.signatures.keys().cloned().collect::<Vec<_>>();
            let mut ciphers_with_proof_indices = Vec::new();
            for i in 0..self.num_of_nodes{
                if !signer_indices.contains(&i){
                    ciphers_with_proof_indices.push(i);
                }
            }

            if ciphers_with_proof_indices.len() != ciphers_with_proof.len(){
                return Err(DkgError::EncryptedDealingVerificationError("Encrypted Dealing is invalid".to_string()));
            }

            for i in 0..ciphers_with_proof_indices.len(){
                ciphers_with_proof_map.insert(ciphers_with_proof_indices[i], ciphers_with_proof[i].clone());
            }
        }

        let dealing_commitment_with_ciphers = DealingCommitmentwithCiphers{
            bls12381_commitment: dealing_commitment.bls12381_commitment.clone(),
            ciphers_12381: ciphers_with_proof_map,
        };

        let dealing_commitment_with_ciphers_bytes = dealing_commitment_with_ciphers.to_vec();

        Ok((compute_accumulation_value(&dealing_commitment_with_ciphers_bytes,
                                   self.num_of_dealer_clan_nodes as usize,
                                   self.threshold_clan as usize)
            .map_err(|x|{
                DkgError::GeneralError(format!("Failed to compute accumulation value: {}",x))
            })?, dealing_commitment_with_ciphers))
    }

    /// Verifies input signature on dealing and stores it.
    /// Error is returned if verification fails.
    pub fn consume_dealing_vote(
        &mut self,
        cgdkg_signature: DealingSignature,
        (index, cg_public_key): (u32, &CGPublicKey),
    ) -> Result<(), DkgError> {
        if self.node_type != NodeType::DealerClanNode{
            return Err(DkgError::GeneralError(
                "Invalid Node Type".to_string(),
            ));
        }

        if let Some(combined_dealing) = self.generated_dealing.as_ref(){

            let share_commitment = ShareCommitment{
                dealer_id: combined_dealing.dealing_commitment.dealer_id,
                instance_id: combined_dealing.dealing_commitment.instance_id,
                g_12381: combined_dealing.dealing_commitment.bls12381_commitment.g.clone(),
                commitment_12381: combined_dealing.dealing_commitment.bls12381_commitment.evals[(index+1) as usize].clone(),
            };

            let dealing_bytes = share_commitment.to_vec();
            if !cg_public_key.verify_commitment_signature(&dealing_bytes, &cgdkg_signature) {
                return Err(DkgError::GeneralError(
                    "Unable to verify signature on dealing".to_string(),
                ));
            }

            if let Some(dealing_votes) = self.dealing_votes.as_mut(){
                dealing_votes[index as usize] = Some(cgdkg_signature);
            }
            Ok(())
        }
        else {
            Err(DkgError::GeneralError(
                "Unable to verify sig as dealing is not generated yet".to_string(),
            ))
        }
    }

    // the family node stores dealing meta votes and tries to create dkg meta once enough dealing meta votes
    // are collected
    pub fn consume_dealing_meta_vote(
        &mut self,
        dealing_meta_with_signature: &DealingMetaWithSignature,
        sender_vk: &CGPublicKey,
        sender_index: u32,
        epoch: u64) -> Result<Option<DKGMeta>, DkgError> {

        if self.node_type != NodeType::FamilyNode{
            return Err(DkgError::GeneralError(
                "Invalid Node Type".to_string(),
            ));
        }

        // basic validation
        if dealing_meta_with_signature.dealing_meta.instance_id != epoch as u32{
            return Err(DkgError::GeneralError("Dealing Meta with invalid instance_id".to_string()));
        }

        // if dkg meta is already generated, we do not need to do anything further
        if self.dkg_meta.is_some(){
            return Ok(None);
        }

        // if we have already generated QC for this dealing meta we do not need to do anything further
        if let Some(dealing_meta_qcs) = self.dealing_meta_qcs.as_ref() {
            if dealing_meta_qcs.contains_key(&dealing_meta_with_signature.dealing_meta){
                return Ok(None);
            }
        }

        // otherwise we just store the signature without verification
        if let Some(dealing_meta_votes) = self.dealing_meta_votes.as_mut(){
            let individual_dealing_meta_votes_map = dealing_meta_votes.entry(dealing_meta_with_signature.dealing_meta.clone())
                .or_insert_with(HashMap::new);

            // store the signature without verification
            individual_dealing_meta_votes_map.insert(sender_index, (dealing_meta_with_signature.signature, sender_vk.clone()));

            // Once we have received >=threshold_clan signatures, we try to create a valid aggregate signature
            // from all signature combinations
            if individual_dealing_meta_votes_map.len() >= self.threshold_clan as usize{

                if let Some((signers, agg_sig)) = try_create_bls_aggregate_signature(
                    &dealing_meta_with_signature.dealing_meta.to_vec(),
                    &individual_dealing_meta_votes_map,
                    self.threshold_clan as usize){

                    // if successful we can add this aggregate signature of dealing_meta_qcs
                    if let Some(dealing_meta_qcs) = self.dealing_meta_qcs.as_mut() {
                        dealing_meta_qcs.insert(dealing_meta_with_signature.dealing_meta.clone(), (signers, agg_sig));

                        if dealing_meta_qcs.len() == self.threshold_clan as usize{
                            let dkg_meta = DKGMeta::new(dealing_meta_qcs.clone());

                            if let Ok(dkg_meta_compressed) = DKGMetaCompressed::try_from(
                                (&dkg_meta, self.num_of_dealer_clan_nodes, self.threshold_clan)){
                                self.dkg_meta = Some(dkg_meta_compressed);
                                return Ok(Some(dkg_meta));
                            }
                            else{
                                return Err(DkgError::GeneralError("Failed to create compressed DKGMeta".to_string()));
                            }
                        }
                    }
                }
            }
        }
        Ok(None)
    }

    pub fn validate_and_sign_dkg_meta(&mut self, dkg_meta: &DKGMeta,
                                      committee_verification_keys: &BTreeMap<u32, PublicKeyBlst>,
                                      epoch: u64)
                                      -> Result<DKGMetaWithSignature, DkgError> {

        if self.node_type != NodeType::DealerClanNode{
            return Err(DkgError::GeneralError(
                "Invalid Node Type".to_string(),
            ));
        }

        if dkg_meta.verify_meta_dkg(self.threshold_clan, epoch, committee_verification_keys){

            //println!("Node: {:?} signing dkg meta!", self.index());

            if let Ok(dkg_meta_compressed) = DKGMetaCompressed::try_from(
                (dkg_meta, self.num_of_dealer_clan_nodes, self.threshold_clan)){

                if let Some(voted_dkg_metas) = self.voted_dkg_metas.as_mut(){
                    voted_dkg_metas.insert(Hash(dkg_meta_compressed.accumulation_value), DKGMetaZis::try_from(dkg_meta).unwrap());
                }

                let signature = self.cg_private_key.sign_bls(&dkg_meta_compressed.to_vec());
                let dkg_meta_with_signature = DKGMetaWithSignature {
                    dkg_meta: dkg_meta_compressed,
                    signature,
                };

                Ok(dkg_meta_with_signature)
            }
            else{
                Err(DkgError::GeneralError("Failed to create compressed DKG meta".to_string()))
            }
        }
        else{
            Err(DkgError::GeneralError(
                "Unable to verify dkg meta ".to_string(),
            ))
        }
    }

    pub fn consume_vote_on_dkg_meta(&mut self,
                                    dkg_meta_sig: &DKGMetaWithSignature,
                                    sender_vk: &CGPublicKey,
                                    sender_index: u32,)
        -> Result<Option<DKGMetaWithAggregateSignature>, DkgError> {

        if self.node_type != NodeType::FamilyNode{
            return Err(DkgError::GeneralError(
                "Invalid Node Type".to_string(),
            ));
        }

        if let Some(dkg_meta) = self.dkg_meta.as_ref(){

            if !dkg_meta.eq(&dkg_meta_sig.dkg_meta){
                return Err(DkgError::GeneralError("Invalid DKG Meta".to_string()));
            }

            if let Some(dkg_meta_votes) = self.dkg_meta_votes.as_mut(){
                //if we already have threshold_clan dkg meta votes, we donot need to process new votes
                if dkg_meta_votes.len() == self.threshold_clan as usize{
                    return Ok(None);
                }

                // otherwise add vote if the signature is correct
                if !sender_vk.verify_signature_bls(&dkg_meta_sig.dkg_meta.to_vec(), &dkg_meta_sig.signature){
                    return Err(DkgError::GeneralError(
                        "Unable to verify signature as DKG Meta".to_string(),
                    ));
                }

                dkg_meta_votes.insert(sender_index, dkg_meta_sig.signature);
                if dkg_meta_votes.len() == self.threshold_clan as usize{

                    let all_signer_indices = dkg_meta_votes.keys().cloned().collect::<Vec<u32>>();
                    let all_sigs: Vec<&SignatureBLS> = dkg_meta_votes.values().collect();
                    let votes_qc = AggregateSignatureBLS::aggregate(all_sigs.as_slice(), false)
                        .map_err(|_| DkgError::GeneralError("Unable to aggregate signatures".to_string()))?;

                    let dkg_meta_with_qc = DKGMetaWithAggregateSignature{
                        family_node_index: self.index,
                        dkg_meta: dkg_meta.clone(),
                        signers: all_signer_indices,
                        signature: votes_qc
                    };

                    return Ok(Some(dkg_meta_with_qc));
                }
                Ok(None)
            }
            else {
                Err(DkgError::GeneralError("DKG Meta Votes does not exist".to_string()))
            }
        }
        else {
            Err(DkgError::GeneralError("DKG Meta does not exist yet".to_string()))
        }
    }

    pub fn add_dkg_meta_qc(&mut self, dkg_meta_qc: &DKGMetaWithAggregateSignature, cg_public_keys: &BTreeMap<u32, CGPublicKey>) -> Result<(), DkgError> {

        // only set if we have not received any dkg_meta before
        if self.dkg_meta_qc.is_none(){

            //todo: this verification may not be needed as it is already verified by the smart contract
            let mut vks = Vec::new();
            cg_public_keys.iter()
                .for_each(|(node_index, public_key)|
                    {
                        if dkg_meta_qc.signers.contains(node_index){
                            vks.push(&public_key.verification_key_bls);
                        }
                    });

            let agg_public_key =
                AggregatePublicKeyBLS::aggregate(vks.as_slice(), false)
                    .map_err(|_| DkgError::GeneralError("Unable to aggregate public keys".to_string()))?;
            let vk = agg_public_key.to_public_key();

            let signature = dkg_meta_qc.signature.to_signature();

            if verify_signature(&vk, &dkg_meta_qc.dkg_meta.to_vec(), &signature){
                self.dkg_meta_qc = Some(dkg_meta_qc.clone());
                Ok(())
            }
            else{
                Err(DkgError::GeneralError("DKG Meta QC verification failed".to_string()))
            }
        }
        else{
            Err(DkgError::GeneralError("Already received DKG Meta".to_string()))
        }
    }

    pub fn dealing_vote_len(&self) -> usize {
        if let Some(dealing_votes) = self.dealing_votes.as_ref() {
            dealing_votes.iter().filter(|item| item.is_some()).count()
        }
        else{
            0
        }
    }

    pub fn try_aggregate_dealings(
        &mut self,
    ) -> Result<(BlsPrivateKey, BlsPublicKey, AggregatedDealingCommitmentwithCiphers), DkgError> {

        if self.node_type != NodeType::DealerClanNode{
            return Err(DkgError::GeneralError(
                "Invalid Node Type".to_string(),
            ));
        }

        if self.aggregated == true{
            return Err(DkgError::GeneralError(
                "Dealings already aggregated".to_string(),
            ));
        }

        let cl_12381 = crypto::bls12381::utils::get_cl();

        // verify that we have received all DealingCommitmentwithCiphers for all zi's in meta_dkg_zis
        if let Some(dkg_meta_zis) = self.dkg_meta_zis.as_ref(){
            let zis = dkg_meta_zis.zis.clone();

            if let Some(dkg_meta_commitment_with_ciphers) = self.dkg_meta_commitment_with_ciphers.as_ref(){
                let zis_dealing_comm_with_ciphers: HashSet<_> = dkg_meta_commitment_with_ciphers.keys().collect();
                let has_all_required_comm_and_ciphers = zis.iter().all(|(_, hash)| zis_dealing_comm_with_ciphers.contains(&Hash(*hash)));

                if has_all_required_comm_and_ciphers{

                    let zis_vector = zis.values().cloned().collect::<Vec<_>>();

                    // aggregating commitments
                    let aggregate_comm_with_ciper_first = dkg_meta_commitment_with_ciphers.get(&Hash(zis_vector[0])).unwrap();
                    let mut agg_commitment_bls12381 = aggregate_comm_with_ciper_first.bls12381_commitment.clone();

                    for i in 1..zis_vector.len(){
                        let aggregate_comm_with_ciper_at_i = dkg_meta_commitment_with_ciphers.get(&Hash(zis_vector[i])).unwrap();
                        agg_commitment_bls12381+= aggregate_comm_with_ciper_at_i.bls12381_commitment.clone();
                    }

                    //aggregating ciphers
                    let mut aggregated_ciphers_12381_map = BTreeMap::new();

                    for i in 0..self.num_of_nodes{
                        let mut cipher_shares_for_node = Vec::new();
                        let mut dealer_list_for_ciphers = Vec::new();

                        //get cipher shares for a particular node from all encrypted dealings in zi
                        for (dealer_id, zi_hash) in zis.iter(){

                            let aggregate_comm_with_ciper =
                                dkg_meta_commitment_with_ciphers.get(&Hash(*zi_hash)).unwrap().ciphers_12381.clone();

                            if let Some(cipher) = aggregate_comm_with_ciper.get(&i){
                                cipher_shares_for_node.push(cipher.clone());
                                dealer_list_for_ciphers.push(*dealer_id);
                            }
                        }

                        //sum cipher shares
                        if cipher_shares_for_node.len() > 0{
                            let mut cipher_sum = cipher_shares_for_node[0].clone();
                            for j in 1..cipher_shares_for_node.len(){
                                let cipher_at_j = cipher_shares_for_node[j].clone();
                                cipher_sum = unsafe{ cipher_sum.add(&cl_12381, &cipher_at_j)};
                            }

                            // add cipher sum with all the dealers who provided the cipher share
                            aggregated_ciphers_12381_map.insert(i, (dealer_list_for_ciphers, cipher_sum));
                        }
                    }

                    self.aggregated = true;

                    // Add cipher share when aggregating my share
                    let mut agg_share12381_big = Fr::zero();
                    if let Some((_, my_cipher)) = aggregated_ciphers_12381_map.get(&self.index){
                        agg_share12381_big = self.decrypt_self_share(&my_cipher);
                    }

                    // Add plaintext shares aggregating my share
                    let mut dealers_for_plaintext_shares = zis.keys().cloned().collect::<Vec<_>>();

                    if let Some((cipher_share_dealers, _)) = aggregated_ciphers_12381_map.get(&self.index){
                        dealers_for_plaintext_shares.retain(|x| !cipher_share_dealers.contains(x));
                    }

                    for dealer_id in dealers_for_plaintext_shares{
                        if let Some(pt_share) = self.individual_dealing.get(&dealer_id){
                            //crypto::bls12381::scalar_bls12381::field_add_assign(&mut agg_share12381_big, &pt_share.cg12381_share.clone())
                            agg_share12381_big += pt_share.cg12381_share.clone()
                        }
                        else {
                            return Err(DkgError::GeneralError("Unable to find Individual dealing share of the node".to_string()));
                        }
                    }

                    let bls_pub_key_12381 = BlsPublicKey {
                        bls12381: agg_commitment_bls12381.evals[0].clone(),
                    };
                    self.finalized_aggregate_commitments = Some(
                        AggregateCommitment{
                            bls12381_commitment: agg_commitment_bls12381.clone(),
                            dealer_ids: zis.keys().cloned().collect::<Vec<_>>(),
                        });

                    let agg_comm_with_ciphers =
                        AggregatedDealingCommitmentwithCiphers{
                            bls12381_commitment: agg_commitment_bls12381.clone(),
                            ciphers_12381: aggregated_ciphers_12381_map
                        };

                    return Ok(
                        (
                            BlsPrivateKey { bls12381: agg_share12381_big },
                            bls_pub_key_12381.into(),
                            agg_comm_with_ciphers,
                        )
                    );
                }
            }
        }

        Err(DkgError::GeneralError(
            "Dealing Aggregation Failed! Make sure Deliver protocol has been completed".to_string(),
        ))
    }

    pub fn get_finalized_aggregate_commitments(&self) -> Option<AggregateCommitment>{
        self.finalized_aggregate_commitments.clone()
    }

    fn decrypt_self_share(&self, my_cipher_12381: &CiphertextBox) -> Fr {

        let cl_12381 = crypto::bls12381::utils::get_cl();
        let mut share12381_mpz = crypto::bls12381::cg_encryption::decrypt(&cl_12381, self.cg_private_key.decryption_key_bls12381(), my_cipher_12381);
        let share12381_big = unsafe{crypto::bls12381::utils::mpz_to_fr(&mut share12381_mpz.0)};
        share12381_big
    }

    pub fn add_finalized_aggregate_commitment(&mut self, agg_commit: &AggregateCommitment) -> Result<Option<(BlsPrivateKey, BlsPublicKey)>, DkgError>{
        if self.finalized_aggregate_commitments.is_none(){
            self.finalized_aggregate_commitments = Some(agg_commit.clone());

            let received_dealings_from_dealers = self.individual_dealing.keys().cloned().collect::<Vec<_>>();
            let dealers_in_agg_commitment = agg_commit.dealer_ids.clone();

            // if we already have all dealing shares as plaintext
            // we donot need to consider encrypted shares
            if dealers_in_agg_commitment.iter().all(|x| received_dealings_from_dealers.contains(x)){
                let mut self_share = Fr::zero();

                for dealer_id in dealers_in_agg_commitment.clone(){
                    if let Some(pt_share) = self.individual_dealing.get(&dealer_id){
                        self_share += pt_share.cg12381_share.clone()
                    }
                    else {
                        return Err(DkgError::GeneralError(format!("Unable to find Individual dealing share of the node: {}", self.index)));
                    }
                }

                self.aggregated = true;
                self.partial_decrypted_share = Some(self_share);
            }
            else if let Some(self_share) = self.partial_decrypted_share.as_mut(){
                self.aggregated = true;

                for dealer_id in dealers_in_agg_commitment{
                    if let Some(pt_share) = self.individual_dealing.get(&dealer_id){
                        *self_share += pt_share.cg12381_share.clone()
                    }
                    else {
                        return Err(DkgError::GeneralError(format!("Unable to find Individual dealing share of the node: {}", self.index)));
                    }
                }
            }

            if self.aggregated{
                return Ok(Some( (
                    BlsPrivateKey{ bls12381: self.partial_decrypted_share.unwrap() },
                    BlsPublicKey{ bls12381: agg_commit.bls12381_commitment.evals[0].clone() }
                )));
            }
        }
        Ok(None)
    }

    pub fn add_finalized_aggregate_encrypted_share(&mut self,
                                                   agg_enc_share: &AggregateEncryptedShare,
                                                   sender_index: u32) -> Result<Option<(BlsPrivateKey, BlsPublicKey)>, DkgError>{

        if self.node_type != NodeType::DealerClanNode{
            if self.aggregate_encrypted_shares.is_none(){
                self.aggregate_encrypted_shares = Some(HashMap::new());
            }

            if let Some(aggregate_encrypted_shares) = self.aggregate_encrypted_shares.as_mut() {
                let entry  = aggregate_encrypted_shares.entry(agg_enc_share.clone()).or_insert(Vec::new());
                entry.push(sender_index);

                if entry.len() == self.threshold_clan as usize{
                    let mut agg_share = self.decrypt_self_share(&agg_enc_share.cipher_12381);
                    // if we have already received agg commitment with dealer ids, we can compute final share
                    if let Some(agg_commitment) = self.finalized_aggregate_commitments.as_ref(){
                        self.aggregated = true;
                        let dealer_ids = agg_commitment.dealer_ids.clone();
                        for dealer_id in dealer_ids{
                            if let Some(pt_share) = self.individual_dealing.get(&dealer_id){
                                agg_share += pt_share.cg12381_share.clone()
                            }
                            else {
                                return Err(DkgError::GeneralError(format!("Unable to find Individual dealing share of the node: {}", self.index)));
                            }
                        }
                    }

                    self.partial_decrypted_share = Some(agg_share);
                    if self.aggregated{
                        return Ok(Some( (
                            BlsPrivateKey {
                                bls12381: self.partial_decrypted_share.clone().unwrap()
                            },
                            BlsPublicKey{
                                bls12381: self.finalized_aggregate_commitments.clone().unwrap().bls12381_commitment.evals[0].clone()
                            },
                        )));
                    }
                }
            }
        }
        Ok(None)
    }

    pub fn get_voted_dkg_meta_zis(&self, accumulation_zm: &Hash) -> Option<&DKGMetaZis>{

        if self.node_type != NodeType::DealerClanNode{
            return None;
        }

        if let Some(voted_dkg_metas) = self.voted_dkg_metas.as_ref() {
            return voted_dkg_metas.get(accumulation_zm);
        }
        None
    }

    pub fn add_self_encrypted_dealing(&mut self, encrypted_dealing_with_proof: EncryptedDealingWithProof)
    -> Result<(), DkgError> {

        let (accumulation_value, dealing_commitment_with_ciphers) =
            self.compute_accumulation_value_encrypted_dealing(&encrypted_dealing_with_proof)?;
        self.encrypted_dealing.insert(accumulation_value, dealing_commitment_with_ciphers);
        self.self_encrypted_dealing_generated = true;
        Ok(())
    }

    pub fn is_self_encrypted_dealing_generated(&self) -> bool{
        self.self_encrypted_dealing_generated
    }

    pub fn add_dkg_meta_zis(&mut self, dkg_meta_zis: &DKGMetaZis) -> Result<(), DkgError> {
        if self.dkg_meta_zis.is_none(){
            self.dkg_meta_zis = Some(dkg_meta_zis.clone());
            Ok(())
        }
        else{
            Err(DkgError::GeneralError("DKG Meta zis already set".to_string()))?
        }
    }

    pub fn get_all_ciphers_and_comms_in_meta_dkg(&self) -> Vec<DealingCommitmentwithCiphers>{

        let mut all_ciphers_and_comms_in_dkg_meta = Vec::new();
        if let Some(dkg_meta_zis) = self.dkg_meta_zis.as_ref() {

            let zi_hashes = dkg_meta_zis.zis.values().cloned().collect::<Vec<_>>();
            all_ciphers_and_comms_in_dkg_meta = self.encrypted_dealing.iter()
                .filter(|(accumulation, _)|{
                    zi_hashes.contains(&accumulation.0)
            })
                .map(|(_, dealing_commitment_with_ciphers)|
                    dealing_commitment_with_ciphers.clone()
                ).collect();
        }
        all_ciphers_and_comms_in_dkg_meta
    }

    pub fn get_dkg_meta_zis_len(&self) -> usize{
        if let Some(dkg_meta_zis) = &self.dkg_meta_zis{
            dkg_meta_zis.zis.len()
        }
        else{
            0
        }
    }

    pub fn index(&self) -> u32{
        self.index
    }

    pub fn add_dkg_meta_dealing_comm_with_cipher(&mut self,
                                                 accumulation: &Hash,
                                                 dealing_comm_with_cipher: &DealingCommitmentwithCiphers)
        -> usize{

        if self.dkg_meta_commitment_with_ciphers.is_none(){
            self.dkg_meta_commitment_with_ciphers = Some(BTreeMap::new());
        }

        if let Some(dkg_meta_commitment_with_ciphers) = self.dkg_meta_commitment_with_ciphers.as_mut(){
            dkg_meta_commitment_with_ciphers.insert(accumulation.clone(), dealing_comm_with_cipher.clone());
            dkg_meta_commitment_with_ciphers.len()
        }
        else{
            0
        }
    }

    pub fn get_dkg_meta_accumulation(&self) -> Option<Hash>{
        Some(Hash(self.dkg_meta_qc.clone()?.dkg_meta.accumulation_value))
    }

    pub fn sign_message_bls(&self, msg: &Vec<u8>) -> SignatureBLS {
        self.cg_private_key.sign_bls(msg)
    }

    pub fn node_type(&self) -> NodeType{
        self.node_type
    }

    pub fn dealing_len(&self) -> usize {
        self.individual_dealing.len()
    }

    pub fn encrypted_dealing_len(&self) -> usize {
        self.encrypted_dealing.len()
    }

    pub fn threshold(&self) -> u32 {
        self.threshold
    }

    pub fn threshold_clan(&self) -> u32 {
        self.threshold_clan
    }

    pub fn num_of_nodes(&self) -> u32 {
        self.num_of_nodes
    }

    /// Checks whether the CG-DKG state has at least threshold votes collected for own dealing to proceed to the next step.
    pub fn has_enough_dealing_votes(&self) -> bool {
        self.dealing_vote_len() >= self.threshold() as usize
    }

    pub fn has_all_dealing_votes(&self) -> bool {
        self.dealing_vote_len() == self.num_of_nodes as usize
    }
}

#[cfg(test)]
mod tests {
    use crate::cgdkg::{CGDkg, NodeType};
    use crate::cgdkg::{CGIndividualDealing, CGPublicKey, CGSecretKey};

    #[test]
    fn test_serilization_deserilization() {
        let cgsecret = CGSecretKey::generate();
        let cgpublic = CGPublicKey::try_from(&cgsecret).unwrap();

        let secret_bytes = cgsecret.to_vec();
        let new_cgsecret = CGSecretKey::try_from(secret_bytes.as_slice()).unwrap();
        assert_eq!(cgsecret.to_vec(), new_cgsecret.to_vec());

        let public_bytes = cgpublic.to_vec();
        let new_cgpublic = CGPublicKey::try_from(public_bytes.as_slice()).unwrap();
        assert_eq!(cgpublic.to_vec(), new_cgpublic.to_vec());

        let mut cgdkg = CGDkg::new(200, 150, 101, 51, 1000, cgsecret, 0, NodeType::DealerClanNode);

        let dealing = cgdkg.generate_individual_dealing(0).unwrap();
        let single_dealing_bytes = dealing[0].to_vec();

        let single_dealing =
            CGIndividualDealing::try_from(single_dealing_bytes.as_slice()).unwrap();
        assert_eq!(single_dealing.to_vec(), single_dealing_bytes);
    }
}

// standalone function to verify and sign encrypted dealing without access to node state
pub fn validate_and_sign_encrypted_dealing(
    dealing: EncryptedDealingWithProof,
    index: u32,
    epoch: u64,
    committee_nodes_pks: BTreeMap<u32, CGPublicKey>,
    num_of_nodes: u32,
    threshold: u32,
    num_of_dealer_clan_nodes: u32,
    threshold_clan: u32,
    node_type: NodeType,
    cg_private_key: CGSecretKey,
) -> Result<(Hash, DealingCommitmentwithCiphers, DealingMetaWithSignature), DkgError> {
    if node_type != NodeType::DealerClanNode {
        return Err(DkgError::GeneralError("Invalid Node Type".to_string()));
    }

    if dealing.dealing_commitment.dealer_id != index || dealing.dealing_commitment.instance_id != epoch as u32 {
        return Err(DkgError::EncryptedDealingVerificationError("Dealing with invalid dealer_id or instance_id".to_string()));
    }

    if !dealing.verify(&committee_nodes_pks, threshold) {
        return Err(DkgError::EncryptedDealingVerificationError("Encrypted Dealing verification failed".to_string()));
    }

    let (accumulation_value, dealing_commitment_with_ciphers) =
        compute_accumulation_value_encrypted_dealing(&dealing, num_of_nodes, num_of_dealer_clan_nodes, threshold_clan)?;
    let commitment_key_12381 = dealing.dealing_commitment.bls12381_commitment.evals[0].clone();
    let dealing_meta = DealingMeta {
        dealer_id: dealing.dealing_commitment.dealer_id,
        instance_id: dealing.dealing_commitment.instance_id,
        accumulation_value: accumulation_value.0,
        commitment_sk_12381: commitment_key_12381,
    };
    let signature = cg_private_key.sign_bls(&dealing_meta.to_vec());

    Ok((
        accumulation_value,
        dealing_commitment_with_ciphers,
        DealingMetaWithSignature {
            dealing_meta,
            signature,
        },
    ))
}

// Helper function extracted from CGDkg
fn compute_accumulation_value_encrypted_dealing(
    dealing: &EncryptedDealingWithProof,
    num_of_nodes: u32,
    num_of_dealer_clan_nodes: u32,
    threshold_clan: u32

) -> Result<(Hash, DealingCommitmentwithCiphers), DkgError> {
    let dealing_commitment = dealing.dealing_commitment.clone();
    let mut ciphers_with_proof_map = BTreeMap::new();

    if let Some(ciphers_with_sharing_proof) = dealing.ciphers_with_sharing_proof.as_ref() {
        let ciphers_with_proof = ciphers_with_sharing_proof.ciphers_with_sharing_proof_12381.ciphers.clone();
        let signer_indices = dealing.signatures.keys().cloned().collect::<Vec<_>>();
        let mut ciphers_with_proof_indices = Vec::new();

        for i in 0..num_of_nodes {
            if !signer_indices.contains(&i) {
                ciphers_with_proof_indices.push(i);
            }
        }

        if ciphers_with_proof_indices.len() != ciphers_with_proof.len() {
            return Err(DkgError::EncryptedDealingVerificationError("Encrypted Dealing is invalid".to_string()));
        }

        for i in 0..ciphers_with_proof_indices.len() {
            ciphers_with_proof_map.insert(ciphers_with_proof_indices[i], ciphers_with_proof[i].clone());
        }
    }

    let dealing_commitment_with_ciphers = DealingCommitmentwithCiphers {
        bls12381_commitment: dealing_commitment.bls12381_commitment.clone(),
        ciphers_12381: ciphers_with_proof_map,
    };

    let dealing_commitment_with_ciphers_bytes = dealing_commitment_with_ciphers.to_vec();
    Ok((
        compute_accumulation_value(&dealing_commitment_with_ciphers_bytes, num_of_dealer_clan_nodes as usize, threshold_clan as usize)?,
        dealing_commitment_with_ciphers,
    ))
}

pub fn validate_and_sign_dkg_meta(dkg_meta: &DKGMeta,
                                  committee_verification_keys: &BTreeMap<u32, PublicKeyBlst>,
                                  epoch: u64,
                                  node_type: NodeType,
                                  num_of_dealer_clan_nodes: u32,
                                  threshold_clan: u32,
                                  cg_private_key: CGSecretKey)
                                  -> Result<(Hash, DKGMetaZis, DKGMetaWithSignature), DkgError> {

    if node_type != NodeType::DealerClanNode{
        return Err(DkgError::GeneralError(
            "Invalid Node Type".to_string(),
        ));
    }

    if dkg_meta.verify_meta_dkg(threshold_clan, epoch, committee_verification_keys){

        //println!("Node: {:?} signing dkg meta!", self.index());

        if let Ok(dkg_meta_compressed) = DKGMetaCompressed::try_from(
            (dkg_meta, num_of_dealer_clan_nodes, threshold_clan)){

            /*if let Some(voted_dkg_metas) = self.voted_dkg_metas.as_mut(){
                voted_dkg_metas.insert(Hash(dkg_meta_compressed.accumulation_value), DKGMetaZis::try_from(dkg_meta).unwrap());
            }*/

            let signature = cg_private_key.sign_bls(&dkg_meta_compressed.to_vec());
            let dkg_meta_with_signature = DKGMetaWithSignature {
                dkg_meta: dkg_meta_compressed.clone(),
                signature,
            };

            Ok((Hash(dkg_meta_compressed.accumulation_value), DKGMetaZis::try_from(dkg_meta).unwrap(), dkg_meta_with_signature))
        }
        else{
            Err(DkgError::GeneralError("Failed to create compressed DKG meta".to_string()))
        }
    }
    else{
        Err(DkgError::GeneralError(
            "Unable to verify dkg meta ".to_string(),
        ))
    }
}